#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"

/**
* Global defs
*/
double** matrix1; //for the first matrix
double** matrix2; //for the second matrix
double** outputMatrix; //for the output matrix after multiplication 

/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 */
void mmm_init() {
	//malloc an array of size size (variable) of pointers to ints
	matrix1 = (double**) malloc(sizeof(double*) * size);

	//malloc an array of size size (variable) of pointers to ints
	matrix2 = (double**) malloc(sizeof(double*) * size);

	 //malloc an array of size size (variable) of pointers to ints
	outputMatrix = (double**) malloc(sizeof(double*) * size);

	// iterate through each row and malloc array of size size (variable) of ints
   for (int i = 0; i < size; i++) {
      matrix1[i] = (double*) malloc(sizeof(double) * size);
	  matrix2[i] = (double*) malloc(sizeof(double) * size);
	  outputMatrix[i] = (double*) malloc(sizeof(double) * size);
   }
   
   //fill matrices with rand values 0-99
    for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++){
			matrix1[i][j] = (double) (rand() % 100);
			matrix2[i][j] = (double) (rand() % 100);
		}
	}
}

/**
 * Reset a given matrix to zeroes
 * @param matrix pointer to a 2D array
 */
void mmm_reset(double **matrix) {
	for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++){
  			matrix[i][j] = 0.0; //set each element to 0 for  given matrix
		}
   }
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup() {
	//free up matrix1:
	for (int i = 0; i < size; i++) { //free each row in matrix1
    	free(matrix1[i]);
    	matrix1[i] = NULL;  //remove dangling pointer
	}
	free(matrix1); //free matrix1
	matrix1 = NULL; //no dangling pointers

	//free up matrix2:
	for (int i = 0; i < size; i++) { //free each row in matrix2
    	free(matrix2[i]);
    	matrix2[i] = NULL;  //remove dangling pointer
	}
	free(matrix2); //free matrix2
	matrix2 = NULL; //no dangling pointers

	//free up outputMatrix:
	for (int i = 0; i < size; i++) { //free each row in outputMatrix
    	free(outputMatrix[i]);
    	outputMatrix[i] = NULL;  //remove dangling pointer
	}
	free(outputMatrix); //free outputMatrix
	outputMatrix = NULL; //no dangling pointers
}

/**
 * Sequential MMM that runs mmm without multiple threads
 */
void mmm_seq() {
	for (int i = 0; i < size; i++){ //moves down the columns
		for (int j = 0; j < size; j++){ //computes entire row
			outputMatrix[i][j] = 0;
			for (int x = 0; x < size; x++){ //computes one "square" in the outputMatrix
				outputMatrix[i][j] = outputMatrix[i][j] + (matrix1[i][x] * matrix2[x][j]);
			}
		}
	}

}

/**
 * Parallel MMM that runs mmm with threads
 *  @param args pointer to thread arguments
 */
void *mmm_par(void *args){
	threadArgs *params = (threadArgs*) args; //cast input

	for (int i = params->start; i < params->end; i++){ //moves down columns going from start and end
		for (int j = 0; j < size; j++){ //computes entire row
			partialMult[i][j] = 0;
			for (int x = 0; x < size; x++){ //computes one "square" of partialMult
				partialMult[i][j] = partialMult[i][j] + (matrix1[i][x] * matrix2[x][j]);
			}
		}
	}

	return NULL;
} 
	

/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 * in the result matrices
 */
double mmm_verify() {
		double maxDiff = 0.0;
		for (int i = 0; i < size; i++){
			for (int j = 0; j < size; j++){
				if (outputMatrix[i][j] - tempOutput[i][j] != 0) //if the diff > 0 
					maxDiff = outputMatrix[i][j] - tempOutput[i][j];

			}
		}

	return maxDiff;
}
